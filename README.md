# wsrl_demo
Demonstration / reference code for the Rogue-like winter study course at Williams College.

Branches will be created at (hopefully) useful milestones in the development processes and these notes updated to indicate the specific things that branch achieves.

This branch has two major pieces of functionality, plus important bug fixes for errors that were revealed in the course of that work - the latter was in entity mixin application, game persistence, and window key binding / event handling.

The two major pieces of work that drove this milestone are the UI loop and entities that are active. Work on those two things is tightly intertwined - one can't test an action loop with out active entities, and one can't test multiple active entities without a loop to manage them. To make this easier (though not easy) I used the Schedule and Engine tools provided by rot.js. Scheduler manages a queue of things to happen, and Engine loops through a queue calling the act() method on each thing in turn. With those in place, it's 'only' a matter of implementing an act method for each entity that should be active.

For the avatar entity the act method is 'pause the engine while the place does something, then restart the engine once the player is done'. All the actual input processing remains in uimode.gameplay. Other active entities are similar, except instead of waiting for the player to do something the entity has to decide on its own - this is the earliest AI in the game. Since getting all the timing stuff working is enough of a hassle the AI will be extremely simple - pick one of the 8 directions and try to move there.

Adding the appropriate methods to the appropriate entities is done via mixins. There's a PlayorActor mixin with an act method and an actionDone listener. The former pauses the loop while the player is choosing what action to do, and the latter restarts the loop once the player's action is done. Then there's a WanderActor mixin, which causes an entity to walk in a random direction each time it acts. Each of those mixins also has an init method which adds the entity to the schedule queue. Verifying that things were acting at the right time was a bit challenging, but more because of the limits of the console than the logic involved. I added a tiny delay to the playerActor engine unlocking just to make sure code is executing in the correct order (i.e. that the player actor code is fully finished before any other entities act).

Finally, the schedule needs to be persisted. For that I needed to dive into some of the otherwise hidden pieces of rot.js's Schedule. I needed to access the upcoming events and the ids of the entities that would be acting at those times. That info let me create a simple, persistable data structure (i.e. only strings, numbers, arrays, and hashes) that I could easily add in a new DATASTORE namespace when saving. The recovery of saved schedule data was fairly simple at that point - re-initialize the scheduler (to wipe out anything that was automatically added during other restoration processes) and then queue things up based on the restored schedule data.

One thing of which this work has made me especially aware is how much I rely on the uniqueness of the randomly generated IDs. At some point in the not-too-distant future I should add a generateUniqueId function to my util package and use that instead of directly getting a series of random strings.
