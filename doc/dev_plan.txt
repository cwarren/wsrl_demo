All projects, coding and otherwise, boil down to two fundamental questions- what should we do, and how should we do it? Learning computer programming is largely about the latter. Implementing a large project is as much or more about the former.

------------

Q: How do you eat an elephant?
A: One bite at a time.
Addendum: Which bites are taken when is key to success.

------------

Having handled a couple of items it's a good time to re-visit the task list - remove completed items, add new ones, and figure out priorities for next steps.
- advancement
- items & inventory
- the UI loop and timing
- mobs on the map (presence and interaction)
- mobs in general
- equipment
- key binding system
- help system (at the least, list available actions / commands)
- random tables (ways of selecting at random from a weighted and possibly dynamic set)
- entity event system (entity mixins can raise events and have handlers for events that are raised)
- entity repository (a way of organizing entity templates and getting entities generated from those templates)
- improved map generation and management

Now that there's a system for entities I think it's time to add an entity other than the avatar. This entity will be extremely simple - no actions, it just sits there. Having more than one entity sets up work on:
DONE - map population
*   NEXT - persistence for multiple entities
*     There are a few big questions here: how to handle lots of entities in general? how to handle entity relationships to a map (and object relationships in general)? how to handle map persistence?
*       + maybe use a local data store approach to manage all relationships? I.e. everything gets a unique id and the objects themselves are stored in a big hash, the all relationships (e.g. all the entities on a map, the map for each entity, etc.) are done by the id rather than the object itself. That would mean that relationships could safely be serialized without worrying about entire objects clogging things up.
*       + maps might have to have their own RNG instance to ensure replicability....?
*       + persistence is then handled by serializing all the state attributes of everything in the datastore rather than relying on hierarchical relations of game data structures
*       I'm generally liking where this train of thought is headed.... worth trying it out....
            As I begin going down this path it seems like fully extracting the avatar from uimode.gameplay will be a bit tricky and that aspect may have to wait until UI loop and entity action controllers are handled. Other aspects relating to map stuff _may_ have to wait until a proper map building system is in place. In both cases I think I can move forward with things as is and just refactor when I get to the respective dev tasks.
            NOTE: need to namespace the datastore by type of thing (essentially by constructor) so correct new objects are created on restore
            * I think I have a handle on how to do this, but I really need the map construction routine separated from uimode.gamePlay; as a part of this I'll also be seriously cleaning up UIMode.gamePlay.setupPlay
            !!!! WORKING !!!!! more or less. The persistence stuff is working, as is all the under-the-hood mucking about I had to do to support that. However, I will need to tweak the RNG stuff a bit. Bascially, on game load the game RNG seed is reset, which means new game right after restore is repeatable because the new game sets up a new seed based on a random number generated by the current (just restored) seed. It's a fairly straight forward problem to fox - I just need the main Game object to have it's own, independent RNG to be used for setting up new games. Just.. not this commit. This one is already really big and hairy.
- entity interaction (attacking / attack system)
- entity death/removal
DONE - entity repository (a way of organizing entity templates and getting entities generated from those templates)
Basically, the next milestone is to have the map populated with some kind of very simple mob that the avatar can kill.

In supporting that I might also tackle
- entity event system (entity mixins can raise events and have handlers for events that are raised)

The UI loop needs to be in place before other entities can do anything - that's probably the next major milestone after this one, and will include some kind of mob that does something (i.e. VERY basic AI).

I think these also need to be handled fairly soon (partly to keep the screen uncluttered, and partly to have them in place before we start adding more commands), but probably not at this step
- key binding system
- help system
