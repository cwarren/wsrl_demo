All projects, coding and otherwise, boil down to two fundamental questions- what should we do, and how should we do it? Learning computer programming is largely about the latter. Implementing a large project is as much or more about the former.

------------

Q: How do you eat an elephant?
A: One bite at a time.
Addendum: Which bites are taken when is key to success.

------------

Some of the tasks that would need to be done for a full game aren't really necessary for a base game, so I'm (at least for now) setting them aside. I'm also far enough along that I'm going to put a bit of thought into ordering the milestone list at this point.
Base game:
- mobs that attack the player, enhanced combat
- real game win / lose conditions
- map modification - digging
- items & active symbols
- hunger, food, and eating
- equipment
- treasure drops
- improved map generation - random seeds for maps? seeding items?
Later:
- ongoing actions
- avatar advancement - experience and improvement
- game scoring
- random tables (ways of selecting at random from a weighted and possibly dynamic set)
- multiple maps and moving between them
- improved map tiles and generation - more tile types, variable digging
- throwing things & ranged combat
- improved combat mechanics
- ipad compatibility (capturing input, figuring out key bindings)

With basic sight stuff working and with map visibility stuff out of the way it's time to make mobs a bit more interesting, by which I mean dangerous. I want a mob that will chase the avatar if it sees it. For this I'll add a new actor mixin, or perhaps alter the basic wander one.

There's a lot of interesting stuff that can be done with mob AI, but I'm trying to resist getting pulled too far down that rabbit hole for now...

I'll also look at enhancing combat in general, with separate hit checks and damage checks.

FIXED BUG: when an entity is at a movement limit (e.g. map 10,0) and tries to move beyond that limit (e.g. move (0,-1) it 'bumps' itself, and diagonal moves slide left or right. This is, I think, and artifact of the way movement clamping is handled.
Fix was a simple early cut out if the attempted location was out of bounds (instead of a value clamp at the bounds)
