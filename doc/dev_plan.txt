All projects, coding and otherwise, boil down to two fundamental questions- what should we do, and how should we do it? Learning computer programming is largely about the latter. Implementing a large project is as much or more about the former.

------------

Q: How do you eat an elephant?
A: One bite at a time.
Addendum: Which bites are taken when is key to success.

------------

Having handled a couple of items it's a good time to re-visit the task list - remove completed items, add new ones, and figure out priorities for next steps.
- avatar interacts with the map (e.g. blocked by walls, can dig)
- advancement
- items & inventory
- the UI loop and timing
- mobs on the map (presence and interaction)
- mobs in general
- equipment
- key binding system
- help system (at the least, list available actions / commands)
- random tables (ways of selecting at random from a weighted and possibly dynamic set)

It's tempting to work on building a better map generation system, since that's a) fun and b) heavily impacts player experience. However, having a better map doesn't really help with any of the other tasks. Improving avatar-map interaction is a possibility. It's pretty easy to do at this level of complexity and it's key to play experience. Other mobs should also respect the map, so figuring that out for the avatar will help with mobs in general. Thinking about the avatar and mobs, ideally the avatar is just a special case of a mob which is controlled by the player rather than an AI. So, rather than implementing a bunch of avatar-map behavior stuff as free-floating code it would be better to put it in the more generalized context of mob behavior. To that end it would make sense to get basic mob stuff in place before special-casing a mob as the avatar.

Mobs have a symbol, a name, a place on the map, and an action controller/chooser (AI or player). Controller stuff is complicated, so that should probably be split into a separate task. Also, one very quickly gets into issues of timing. All the complexity revealed on deeper consideration is a sign that this is a good area to tackle while the game is at a very simple stage of its development.

Entities (i.e. mobs) have potentially a wide range of capabilities. Rather than setting up a full inheritance structure I'll be using some kind of mixin-style system to add functionality as needed. This lets me be a little more flexible in my coding approach. Since I established a template-based system of entity creation I can easily specify in the template which mixins an entity has. There's a whole realm of CS work done on the concept of mixins (and traits, and talents, and...) and design and implementation considerations. I'll be using (at least for now) a very simple approach - when a mixin is specified then all the functional and state data will be copied into the instantiated object when it's created. One issue that this approach has is name collisions - e.g. if two different mixins have an attribute called 'state' then things will go wrong when both mixins are used at once because each will be trying to treat 'state' as it's own and will be disrupting what the other is trying to do with it. There are various technical approaches to solving that problem, but for now I'll rely on the extremely simple process approach of using unique names - I may use a naming schema that incorporates some sort of implicit namespacing (e.g. _mixinName_attrName) or I may just wing it since this is a relatively small project with few (one, in my case) coders. However, looking ahead I know I'll have to revisit this issue at some point since I think I'll want to implement an event system eventually.
